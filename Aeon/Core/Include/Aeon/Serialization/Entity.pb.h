// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Entity.proto

#ifndef PROTOBUF_Entity_2eproto__INCLUDED
#define PROTOBUF_Entity_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Datatypes.pb.h"
#include "Attribute.pb.h"
#include "Component.pb.h"
#include "Value.pb.h"
#include "UUID.pb.h"
// @@protoc_insertion_point(includes)

namespace Aeon {
namespace Serialize {

// Internal implementation detail -- do not call these.
void AEON_EXPORT protobuf_AddDesc_Entity_2eproto();
void protobuf_AssignDesc_Entity_2eproto();
void protobuf_ShutdownFile_Entity_2eproto();

class EntityDescriptor;
class EntityInstance;

// ===================================================================

class AEON_EXPORT EntityDescriptor : public ::google::protobuf::Message {
 public:
  EntityDescriptor();
  virtual ~EntityDescriptor();
  
  EntityDescriptor(const EntityDescriptor& from);
  
  inline EntityDescriptor& operator=(const EntityDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityDescriptor& default_instance();
  
  void Swap(EntityDescriptor* other);
  
  // implements Message ----------------------------------------------
  
  EntityDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityDescriptor& from);
  void MergeFrom(const EntityDescriptor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Aeon.Serialize.UUID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Aeon::Serialize::UUID& id() const;
  inline ::Aeon::Serialize::UUID* mutable_id();
  inline ::Aeon::Serialize::UUID* release_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .Aeon.Serialize.UUID category = 3;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 3;
  inline const ::Aeon::Serialize::UUID& category() const;
  inline ::Aeon::Serialize::UUID* mutable_category();
  inline ::Aeon::Serialize::UUID* release_category();
  
  // required .Aeon.Serialize.UUID subcat = 4;
  inline bool has_subcat() const;
  inline void clear_subcat();
  static const int kSubcatFieldNumber = 4;
  inline const ::Aeon::Serialize::UUID& subcat() const;
  inline ::Aeon::Serialize::UUID* mutable_subcat();
  inline ::Aeon::Serialize::UUID* release_subcat();
  
  // repeated .Aeon.Serialize.Attribute attributes = 5;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline const ::Aeon::Serialize::Attribute& attributes(int index) const;
  inline ::Aeon::Serialize::Attribute* mutable_attributes(int index);
  inline ::Aeon::Serialize::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::Attribute >*
      mutable_attributes();
  
  // repeated .Aeon.Serialize.UUID components = 6;
  inline int components_size() const;
  inline void clear_components();
  static const int kComponentsFieldNumber = 6;
  inline const ::Aeon::Serialize::UUID& components(int index) const;
  inline ::Aeon::Serialize::UUID* mutable_components(int index);
  inline ::Aeon::Serialize::UUID* add_components();
  inline const ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::UUID >&
      components() const;
  inline ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::UUID >*
      mutable_components();
  
  // @@protoc_insertion_point(class_scope:Aeon.Serialize.EntityDescriptor)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_subcat();
  inline void clear_has_subcat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Aeon::Serialize::UUID* id_;
  ::std::string* name_;
  ::Aeon::Serialize::UUID* category_;
  ::Aeon::Serialize::UUID* subcat_;
  ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::Attribute > attributes_;
  ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::UUID > components_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void AEON_EXPORT protobuf_AddDesc_Entity_2eproto();
  friend void protobuf_AssignDesc_Entity_2eproto();
  friend void protobuf_ShutdownFile_Entity_2eproto();
  
  void InitAsDefaultInstance();
  static EntityDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class AEON_EXPORT EntityInstance : public ::google::protobuf::Message {
 public:
  EntityInstance();
  virtual ~EntityInstance();
  
  EntityInstance(const EntityInstance& from);
  
  inline EntityInstance& operator=(const EntityInstance& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityInstance& default_instance();
  
  void Swap(EntityInstance* other);
  
  // implements Message ----------------------------------------------
  
  EntityInstance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityInstance& from);
  void MergeFrom(const EntityInstance& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Aeon.Serialize.UUID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Aeon::Serialize::UUID& id() const;
  inline ::Aeon::Serialize::UUID* mutable_id();
  inline ::Aeon::Serialize::UUID* release_id();
  
  // required .Aeon.Serialize.UUID entity_descriptor = 2;
  inline bool has_entity_descriptor() const;
  inline void clear_entity_descriptor();
  static const int kEntityDescriptorFieldNumber = 2;
  inline const ::Aeon::Serialize::UUID& entity_descriptor() const;
  inline ::Aeon::Serialize::UUID* mutable_entity_descriptor();
  inline ::Aeon::Serialize::UUID* release_entity_descriptor();
  
  // repeated .Aeon.Serialize.AttributeInstance values = 3;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 3;
  inline const ::Aeon::Serialize::AttributeInstance& values(int index) const;
  inline ::Aeon::Serialize::AttributeInstance* mutable_values(int index);
  inline ::Aeon::Serialize::AttributeInstance* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::AttributeInstance >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::AttributeInstance >*
      mutable_values();
  
  // repeated .Aeon.Serialize.ComponentInstance components = 4;
  inline int components_size() const;
  inline void clear_components();
  static const int kComponentsFieldNumber = 4;
  inline const ::Aeon::Serialize::ComponentInstance& components(int index) const;
  inline ::Aeon::Serialize::ComponentInstance* mutable_components(int index);
  inline ::Aeon::Serialize::ComponentInstance* add_components();
  inline const ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::ComponentInstance >&
      components() const;
  inline ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::ComponentInstance >*
      mutable_components();
  
  // @@protoc_insertion_point(class_scope:Aeon.Serialize.EntityInstance)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_entity_descriptor();
  inline void clear_has_entity_descriptor();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Aeon::Serialize::UUID* id_;
  ::Aeon::Serialize::UUID* entity_descriptor_;
  ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::AttributeInstance > values_;
  ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::ComponentInstance > components_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void AEON_EXPORT protobuf_AddDesc_Entity_2eproto();
  friend void protobuf_AssignDesc_Entity_2eproto();
  friend void protobuf_ShutdownFile_Entity_2eproto();
  
  void InitAsDefaultInstance();
  static EntityInstance* default_instance_;
};
// ===================================================================


// ===================================================================

// EntityDescriptor

// required .Aeon.Serialize.UUID id = 1;
inline bool EntityDescriptor::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityDescriptor::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityDescriptor::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityDescriptor::clear_id() {
  if (id_ != NULL) id_->::Aeon::Serialize::UUID::Clear();
  clear_has_id();
}
inline const ::Aeon::Serialize::UUID& EntityDescriptor::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Aeon::Serialize::UUID* EntityDescriptor::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Aeon::Serialize::UUID;
  return id_;
}
inline ::Aeon::Serialize::UUID* EntityDescriptor::release_id() {
  clear_has_id();
  ::Aeon::Serialize::UUID* temp = id_;
  id_ = NULL;
  return temp;
}

// required string name = 2;
inline bool EntityDescriptor::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntityDescriptor::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntityDescriptor::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntityDescriptor::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EntityDescriptor::name() const {
  return *name_;
}
inline void EntityDescriptor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void EntityDescriptor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void EntityDescriptor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntityDescriptor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* EntityDescriptor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .Aeon.Serialize.UUID category = 3;
inline bool EntityDescriptor::has_category() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntityDescriptor::set_has_category() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntityDescriptor::clear_has_category() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntityDescriptor::clear_category() {
  if (category_ != NULL) category_->::Aeon::Serialize::UUID::Clear();
  clear_has_category();
}
inline const ::Aeon::Serialize::UUID& EntityDescriptor::category() const {
  return category_ != NULL ? *category_ : *default_instance_->category_;
}
inline ::Aeon::Serialize::UUID* EntityDescriptor::mutable_category() {
  set_has_category();
  if (category_ == NULL) category_ = new ::Aeon::Serialize::UUID;
  return category_;
}
inline ::Aeon::Serialize::UUID* EntityDescriptor::release_category() {
  clear_has_category();
  ::Aeon::Serialize::UUID* temp = category_;
  category_ = NULL;
  return temp;
}

// required .Aeon.Serialize.UUID subcat = 4;
inline bool EntityDescriptor::has_subcat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EntityDescriptor::set_has_subcat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EntityDescriptor::clear_has_subcat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EntityDescriptor::clear_subcat() {
  if (subcat_ != NULL) subcat_->::Aeon::Serialize::UUID::Clear();
  clear_has_subcat();
}
inline const ::Aeon::Serialize::UUID& EntityDescriptor::subcat() const {
  return subcat_ != NULL ? *subcat_ : *default_instance_->subcat_;
}
inline ::Aeon::Serialize::UUID* EntityDescriptor::mutable_subcat() {
  set_has_subcat();
  if (subcat_ == NULL) subcat_ = new ::Aeon::Serialize::UUID;
  return subcat_;
}
inline ::Aeon::Serialize::UUID* EntityDescriptor::release_subcat() {
  clear_has_subcat();
  ::Aeon::Serialize::UUID* temp = subcat_;
  subcat_ = NULL;
  return temp;
}

// repeated .Aeon.Serialize.Attribute attributes = 5;
inline int EntityDescriptor::attributes_size() const {
  return attributes_.size();
}
inline void EntityDescriptor::clear_attributes() {
  attributes_.Clear();
}
inline const ::Aeon::Serialize::Attribute& EntityDescriptor::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::Aeon::Serialize::Attribute* EntityDescriptor::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::Aeon::Serialize::Attribute* EntityDescriptor::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::Attribute >&
EntityDescriptor::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::Attribute >*
EntityDescriptor::mutable_attributes() {
  return &attributes_;
}

// repeated .Aeon.Serialize.UUID components = 6;
inline int EntityDescriptor::components_size() const {
  return components_.size();
}
inline void EntityDescriptor::clear_components() {
  components_.Clear();
}
inline const ::Aeon::Serialize::UUID& EntityDescriptor::components(int index) const {
  return components_.Get(index);
}
inline ::Aeon::Serialize::UUID* EntityDescriptor::mutable_components(int index) {
  return components_.Mutable(index);
}
inline ::Aeon::Serialize::UUID* EntityDescriptor::add_components() {
  return components_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::UUID >&
EntityDescriptor::components() const {
  return components_;
}
inline ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::UUID >*
EntityDescriptor::mutable_components() {
  return &components_;
}

// -------------------------------------------------------------------

// EntityInstance

// required .Aeon.Serialize.UUID id = 1;
inline bool EntityInstance::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityInstance::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityInstance::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityInstance::clear_id() {
  if (id_ != NULL) id_->::Aeon::Serialize::UUID::Clear();
  clear_has_id();
}
inline const ::Aeon::Serialize::UUID& EntityInstance::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Aeon::Serialize::UUID* EntityInstance::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Aeon::Serialize::UUID;
  return id_;
}
inline ::Aeon::Serialize::UUID* EntityInstance::release_id() {
  clear_has_id();
  ::Aeon::Serialize::UUID* temp = id_;
  id_ = NULL;
  return temp;
}

// required .Aeon.Serialize.UUID entity_descriptor = 2;
inline bool EntityInstance::has_entity_descriptor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntityInstance::set_has_entity_descriptor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntityInstance::clear_has_entity_descriptor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntityInstance::clear_entity_descriptor() {
  if (entity_descriptor_ != NULL) entity_descriptor_->::Aeon::Serialize::UUID::Clear();
  clear_has_entity_descriptor();
}
inline const ::Aeon::Serialize::UUID& EntityInstance::entity_descriptor() const {
  return entity_descriptor_ != NULL ? *entity_descriptor_ : *default_instance_->entity_descriptor_;
}
inline ::Aeon::Serialize::UUID* EntityInstance::mutable_entity_descriptor() {
  set_has_entity_descriptor();
  if (entity_descriptor_ == NULL) entity_descriptor_ = new ::Aeon::Serialize::UUID;
  return entity_descriptor_;
}
inline ::Aeon::Serialize::UUID* EntityInstance::release_entity_descriptor() {
  clear_has_entity_descriptor();
  ::Aeon::Serialize::UUID* temp = entity_descriptor_;
  entity_descriptor_ = NULL;
  return temp;
}

// repeated .Aeon.Serialize.AttributeInstance values = 3;
inline int EntityInstance::values_size() const {
  return values_.size();
}
inline void EntityInstance::clear_values() {
  values_.Clear();
}
inline const ::Aeon::Serialize::AttributeInstance& EntityInstance::values(int index) const {
  return values_.Get(index);
}
inline ::Aeon::Serialize::AttributeInstance* EntityInstance::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::Aeon::Serialize::AttributeInstance* EntityInstance::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::AttributeInstance >&
EntityInstance::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::AttributeInstance >*
EntityInstance::mutable_values() {
  return &values_;
}

// repeated .Aeon.Serialize.ComponentInstance components = 4;
inline int EntityInstance::components_size() const {
  return components_.size();
}
inline void EntityInstance::clear_components() {
  components_.Clear();
}
inline const ::Aeon::Serialize::ComponentInstance& EntityInstance::components(int index) const {
  return components_.Get(index);
}
inline ::Aeon::Serialize::ComponentInstance* EntityInstance::mutable_components(int index) {
  return components_.Mutable(index);
}
inline ::Aeon::Serialize::ComponentInstance* EntityInstance::add_components() {
  return components_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::ComponentInstance >&
EntityInstance::components() const {
  return components_;
}
inline ::google::protobuf::RepeatedPtrField< ::Aeon::Serialize::ComponentInstance >*
EntityInstance::mutable_components() {
  return &components_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serialize
}  // namespace Aeon

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Entity_2eproto__INCLUDED
